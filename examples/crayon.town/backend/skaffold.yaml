apiVersion: skaffold/v3
kind: Config
metadata:
  name: crayontown
build:
  artifacts:
    - image: gcr.io/crayontown/crayontown-ws
      docker:
        dockerfile: ws/Dockerfile
    - image: gcr.io/crayontown/crayontown-cleaner
      docker:
        dockerfile: cleaner/Dockerfile
    - image: gcr.io/crayontown/crayontown-images
      docker:
        dockerfile: images/Dockerfile
manifests:
  kustomize:
    paths:
      - k8s/overlays/dev
deploy:
  kubeContext: minikube
  kubectl:
    defaultNamespace: crayontown
  helm:
    releases:
      - name: redis
        remoteChart: oci://registry-1.docker.io/bitnamicharts/redis
        namespace: crayontown
        createNamespace: true
        setValues:
          architecture: standalone
          auth.enabled: false
profiles:
  - name: microk8s
    deploy:
      kubeContext: microk8s
    build:
      local:
        push: true
    patches:
      - op: replace
        path: /build/artifacts/0/image
        value: localhost:32000/crayontown-ws
      - op: replace
        path: /build/artifacts/1/image
        value: localhost:32000/crayontown-cleaner
      - op: replace
        path: /build/artifacts/2/image
        value: localhost:32000/crayontown-images
      - op: replace
        path: /manifests/kustomize/paths
        value:
          - k8s/overlays/microk8s
# Important! When you're using minikube run `minikube tunnel` to expose the services.

# use dev context
# kubectl config use-context minikube

# use microk8s context
# kubectl config use-context microk8s

# Minikube create service account secret
# kubectl create secret generic crayontown-service-account --from-file=./service-account.json --namespace crayontown

# deploy
# skaffold run -p microk8s

# Run cron job manually
# kubectl create job --from=cronjob/crayontown-cleaner crayontown-cleaner-000
