/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.28.2
 * source: models.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace models {
    export class DrawSegment extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tileX?: number;
            tileY?: number;
            startX?: number;
            startY?: number;
            endX?: number;
            endY?: number;
            red?: number;
            green?: number;
            blue?: number;
            alpha?: number;
            size?: number;
            kind?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tileX" in data && data.tileX != undefined) {
                    this.tileX = data.tileX;
                }
                if ("tileY" in data && data.tileY != undefined) {
                    this.tileY = data.tileY;
                }
                if ("startX" in data && data.startX != undefined) {
                    this.startX = data.startX;
                }
                if ("startY" in data && data.startY != undefined) {
                    this.startY = data.startY;
                }
                if ("endX" in data && data.endX != undefined) {
                    this.endX = data.endX;
                }
                if ("endY" in data && data.endY != undefined) {
                    this.endY = data.endY;
                }
                if ("red" in data && data.red != undefined) {
                    this.red = data.red;
                }
                if ("green" in data && data.green != undefined) {
                    this.green = data.green;
                }
                if ("blue" in data && data.blue != undefined) {
                    this.blue = data.blue;
                }
                if ("alpha" in data && data.alpha != undefined) {
                    this.alpha = data.alpha;
                }
                if ("size" in data && data.size != undefined) {
                    this.size = data.size;
                }
                if ("kind" in data && data.kind != undefined) {
                    this.kind = data.kind;
                }
            }
        }
        get tileX() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set tileX(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get tileY() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set tileY(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get startX() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set startX(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get startY() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set startY(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get endX() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set endX(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get endY() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set endY(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get red() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set red(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get green() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set green(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get blue() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set blue(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get alpha() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set alpha(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get size() {
            return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
        }
        set size(value: number) {
            pb_1.Message.setField(this, 11, value);
        }
        get kind() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set kind(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        static fromObject(data: {
            tileX?: number;
            tileY?: number;
            startX?: number;
            startY?: number;
            endX?: number;
            endY?: number;
            red?: number;
            green?: number;
            blue?: number;
            alpha?: number;
            size?: number;
            kind?: number;
        }): DrawSegment {
            const message = new DrawSegment({});
            if (data.tileX != null) {
                message.tileX = data.tileX;
            }
            if (data.tileY != null) {
                message.tileY = data.tileY;
            }
            if (data.startX != null) {
                message.startX = data.startX;
            }
            if (data.startY != null) {
                message.startY = data.startY;
            }
            if (data.endX != null) {
                message.endX = data.endX;
            }
            if (data.endY != null) {
                message.endY = data.endY;
            }
            if (data.red != null) {
                message.red = data.red;
            }
            if (data.green != null) {
                message.green = data.green;
            }
            if (data.blue != null) {
                message.blue = data.blue;
            }
            if (data.alpha != null) {
                message.alpha = data.alpha;
            }
            if (data.size != null) {
                message.size = data.size;
            }
            if (data.kind != null) {
                message.kind = data.kind;
            }
            return message;
        }
        toObject() {
            const data: {
                tileX?: number;
                tileY?: number;
                startX?: number;
                startY?: number;
                endX?: number;
                endY?: number;
                red?: number;
                green?: number;
                blue?: number;
                alpha?: number;
                size?: number;
                kind?: number;
            } = {};
            if (this.tileX != null) {
                data.tileX = this.tileX;
            }
            if (this.tileY != null) {
                data.tileY = this.tileY;
            }
            if (this.startX != null) {
                data.startX = this.startX;
            }
            if (this.startY != null) {
                data.startY = this.startY;
            }
            if (this.endX != null) {
                data.endX = this.endX;
            }
            if (this.endY != null) {
                data.endY = this.endY;
            }
            if (this.red != null) {
                data.red = this.red;
            }
            if (this.green != null) {
                data.green = this.green;
            }
            if (this.blue != null) {
                data.blue = this.blue;
            }
            if (this.alpha != null) {
                data.alpha = this.alpha;
            }
            if (this.size != null) {
                data.size = this.size;
            }
            if (this.kind != null) {
                data.kind = this.kind;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tileX != 0)
                writer.writeSint32(1, this.tileX);
            if (this.tileY != 0)
                writer.writeSint32(2, this.tileY);
            if (this.startX != 0)
                writer.writeSint32(3, this.startX);
            if (this.startY != 0)
                writer.writeSint32(4, this.startY);
            if (this.endX != 0)
                writer.writeSint32(5, this.endX);
            if (this.endY != 0)
                writer.writeSint32(6, this.endY);
            if (this.red != 0)
                writer.writeUint32(7, this.red);
            if (this.green != 0)
                writer.writeUint32(8, this.green);
            if (this.blue != 0)
                writer.writeUint32(9, this.blue);
            if (this.alpha != 0)
                writer.writeUint32(10, this.alpha);
            if (this.size != 0)
                writer.writeUint32(11, this.size);
            if (this.kind != 0)
                writer.writeUint32(12, this.kind);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DrawSegment {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DrawSegment();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tileX = reader.readSint32();
                        break;
                    case 2:
                        message.tileY = reader.readSint32();
                        break;
                    case 3:
                        message.startX = reader.readSint32();
                        break;
                    case 4:
                        message.startY = reader.readSint32();
                        break;
                    case 5:
                        message.endX = reader.readSint32();
                        break;
                    case 6:
                        message.endY = reader.readSint32();
                        break;
                    case 7:
                        message.red = reader.readUint32();
                        break;
                    case 8:
                        message.green = reader.readUint32();
                        break;
                    case 9:
                        message.blue = reader.readUint32();
                        break;
                    case 10:
                        message.alpha = reader.readUint32();
                        break;
                    case 11:
                        message.size = reader.readUint32();
                        break;
                    case 12:
                        message.kind = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DrawSegment {
            return DrawSegment.deserialize(bytes);
        }
    }
    export class Stroke extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            segments?: DrawSegment[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("segments" in data && data.segments != undefined) {
                    this.segments = data.segments;
                }
            }
        }
        get segments() {
            return pb_1.Message.getRepeatedWrapperField(this, DrawSegment, 1) as DrawSegment[];
        }
        set segments(value: DrawSegment[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            segments?: ReturnType<typeof DrawSegment.prototype.toObject>[];
        }): Stroke {
            const message = new Stroke({});
            if (data.segments != null) {
                message.segments = data.segments.map(item => DrawSegment.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                segments?: ReturnType<typeof DrawSegment.prototype.toObject>[];
            } = {};
            if (this.segments != null) {
                data.segments = this.segments.map((item: DrawSegment) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.segments.length)
                writer.writeRepeatedMessage(1, this.segments, (item: DrawSegment) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Stroke {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Stroke();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.segments, () => pb_1.Message.addToRepeatedWrapperField(message, 1, DrawSegment.deserialize(reader), DrawSegment));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Stroke {
            return Stroke.deserialize(bytes);
        }
    }
}
